{"mode":"editor","version":1,"windowDimensions":{"x":203,"y":79,"width":960,"height":1011,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/home/david/programming/cuda/blur_image"],"buffers":[{"text":"#include \"utils.h\"\n\n__global__\nvoid gaussian_blur(const unsigned char* const inputChannel,\n                   unsigned char* const outputChannel,\n                   int numRows, int numCols,\n                   const float* const filter, const int filterWidth)\n{\n    // get thread index\n    int x_idx = blockDim.x * blockIdx.x + threadIdx.x;\n    int y_idx = blockDim.y * blockIdx.y + threadIdx.y;\n    int thread_idx = numCols * y_idx + x_idx;\n\n    if ((x_idx < numCols) && (y_idx < numRows)) {\n    \t// get thread location in relation to the filter\n    \t// this will always give center of filter array width, since filterWidth must be odd to have center pixel\n    \tint center = (filterWidth - 1) / 2;\n\n    \tint x, y, idx, filter_idx;\n    \tfloat total = 0;\n    \tfor (int i = 0; i < filterWidth; i++){\n    \t    for (int j = 0; j < filterWidth; j++){\n        \t\tx = x_idx + j - center; // x value of surrounding pixel\n        \t\ty = y_idx + i - center; // same for y value\n                if (x < 0){ x = 0; } // clamping values outside image boundaries\n                if (y < 0){ y = 0; }\n                if (x >= numCols){ x = numCols - 1; }\n                if (y >= numRows){ y = numRows -1; }\n        \t\tidx = numCols * y + x; // 1D index for surrounding pixel\n        \t\tfilter_idx = filterWidth * i + j; // 1D index of weight value in filter\n                float imageColor = inputChannel[idx];\n                float filterColor = filter[filter_idx];\n        \t\ttotal += imageColor * filterColor;\n    \t    }\n    \t}\n    \toutputChannel[thread_idx] = total;\n    }\n\n}\n\n//This kernel takes in an image represented as a uchar4 and splits\n//it into three images consisting of only one color channel each\n__global__\nvoid separateChannels(const uchar4* const inputImageRGBA,\n                      int numRows,\n                      int numCols,\n                      unsigned char* const redChannel,\n                      unsigned char* const greenChannel,\n                      unsigned char* const blueChannel)\n{\n    // get thread index\n    int x_idx = blockDim.x * blockIdx.x + threadIdx.x;\n    int y_idx = blockDim.y * blockIdx.y + threadIdx.y;\n    int idx = numCols * y_idx + x_idx;\n\n    // seperate values into three channels\n    if ((x_idx < numCols) && (y_idx < numRows)) {\n    \tuchar4 pixel = inputImageRGBA[idx];\n    \tredChannel[idx] = pixel.x;\n    \tgreenChannel[idx] = pixel.y;\n    \tblueChannel[idx] = pixel.z;\n    }\n}\n\n//This kernel takes in three color channels and recombines them\n//into one image.  The alpha channel is set to 255 to represent\n//that this image has no transparency.\n__global__\nvoid recombineChannels(const unsigned char* const redChannel,\n                       const unsigned char* const greenChannel,\n                       const unsigned char* const blueChannel,\n                       uchar4* const outputImageRGBA,\n                       int numRows,\n                       int numCols)\n{\n    const int2 thread_2D_pos = make_int2( blockIdx.x * blockDim.x + threadIdx.x,\n\t\t\t\t\t  blockIdx.y * blockDim.y + threadIdx.y);\n\n    const int thread_1D_pos = thread_2D_pos.y * numCols + thread_2D_pos.x;\n\n    //make sure we don't try and access memory outside the image\n    //by having any threads mapped there return early\n    if (thread_2D_pos.x >= numCols || thread_2D_pos.y >= numRows)\n\treturn;\n\n    unsigned char red   = redChannel[thread_1D_pos];\n    unsigned char green = greenChannel[thread_1D_pos];\n    unsigned char blue  = blueChannel[thread_1D_pos];\n\n    //Alpha should be 255 for no transparency\n    uchar4 outputPixel = make_uchar4(red, green, blue, 255);\n\n    outputImageRGBA[thread_1D_pos] = outputPixel;\n}\n\nunsigned char *d_red, *d_green, *d_blue;\nfloat         *d_filter;\n\nvoid allocateMemoryAndCopyToGPU(const size_t numRowsImage, const size_t numColsImage,\n                                const float* const h_filter, const size_t filterWidth)\n{\n    //allocate memory for the three different channels\n    //original\n    checkCudaErrors(cudaMalloc(&d_red,   sizeof(unsigned char) * numRowsImage * numColsImage));\n    checkCudaErrors(cudaMalloc(&d_green, sizeof(unsigned char) * numRowsImage * numColsImage));\n    checkCudaErrors(cudaMalloc(&d_blue,  sizeof(unsigned char) * numRowsImage * numColsImage));\n\n    // allocate memory for filter array\n    checkCudaErrors(cudaMalloc(&d_filter, sizeof(float) * filterWidth * filterWidth));\n\n    //Copy the filter on the host (h_filter) to the memory you just allocated\n    checkCudaErrors(cudaMemcpy(d_filter, h_filter, sizeof(float) * filterWidth * filterWidth, cudaMemcpyHostToDevice));\n}\n\nvoid your_gaussian_blur(const uchar4 * const h_inputImageRGBA, uchar4 * const d_inputImageRGBA,\n                        uchar4* const d_outputImageRGBA, const size_t numRows, const size_t numCols,\n                        unsigned char *d_redBlurred,\n                        unsigned char *d_greenBlurred,\n                        unsigned char *d_blueBlurred,\n                        const int filterWidth)\n{\n    //TODO: Set reasonable block size (i.e., number of threads per block)\n    const int BLOCK_SIZE = 32;\n    const dim3 blockSize(BLOCK_SIZE, BLOCK_SIZE, 1);\n\n    //TODO:\n    //Compute correct grid size (i.e., number of blocks per kernel launch)\n    //from the image size and and block size.\n    const dim3 gridSize(numCols/blockSize.x + 1, numRows/blockSize.y + 1, 1); // extra block for remainders\n\n    //TODO: Launch a kernel for separating the RGBA image into different color channels\n    separateChannels<<<gridSize, blockSize>>>(d_inputImageRGBA, numRows, numCols, d_red, d_green, d_blue);\n\n    // Call cudaDeviceSynchronize(), then call checkCudaErrors() immediately after\n    // launching your kernel to make sure that you didn't make any mistakes.\n    cudaDeviceSynchronize(); checkCudaErrors(cudaGetLastError());\n\n    //TODO: Call your convolution kernel here 3 times, once for each color channel.\n    gaussian_blur<<<gridSize, blockSize>>>(d_red, d_redBlurred, numRows, numCols, d_filter, filterWidth);\n    gaussian_blur<<<gridSize, blockSize>>>(d_green, d_greenBlurred, numRows, numCols, d_filter, filterWidth);\n    gaussian_blur<<<gridSize, blockSize>>>(d_blue, d_blueBlurred, numRows, numCols, d_filter, filterWidth);\n\n    // Again, call cudaDeviceSynchronize(), then call checkCudaErrors() immediately after\n    // launching your kernel to make sure that you didn't make any mistakes.\n    cudaDeviceSynchronize(); checkCudaErrors(cudaGetLastError());\n\n    // Now we recombine your results. We take care of launching this kernel for you.\n    //\n    // NOTE: This kernel launch depends on the gridSize and blockSize variables,\n    // which you must set yourself.\n    recombineChannels<<<gridSize, blockSize>>>(d_redBlurred,\n\t\t\t\t\t       d_greenBlurred,\n\t\t\t\t\t       d_blueBlurred,\n\t\t\t\t\t       d_outputImageRGBA,\n\t\t\t\t\t       numRows,\n\t\t\t\t\t       numCols);\n    cudaDeviceSynchronize(); checkCudaErrors(cudaGetLastError());\n\n}\n\n\n//Free all the memory that we allocated\n//TODO: make sure you free any arrays that you allocated\nvoid cleanup() {\n    checkCudaErrors(cudaFree(d_red));\n    checkCudaErrors(cudaFree(d_green));\n    checkCudaErrors(cudaFree(d_blue));\n    checkCudaErrors(cudaFree(d_filter));\n}\n","markerStore":{"nextMarkerId":17,"markersById":{"0":{"range":{"start":{"row":31,"column":42},"end":{"row":31,"column":42}},"properties":{"type":"selection","editorId":47,"goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"5":{"range":{"start":{"row":31,"column":42},"end":{"row":31,"column":43}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"6":{"range":{"start":{"row":31,"column":53},"end":{"row":31,"column":54}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"15":{"range":{"start":{"row":31,"column":42},"end":{"row":31,"column":43}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false},"16":{"range":{"start":{"row":31,"column":53},"end":{"row":31,"column":54}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/mnt/David/programming/cuda/blur_image/student_func.cu","digestWhenLastPersisted":"a13e1a026cc616449753bf2e22c57fc50ccfb292","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":47,"softTabs":true,"displayBuffer":{"id":48,"softWrapped":false,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/mnt/David/programming/cuda/blur_image/student_func.cu","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/mnt/David/programming/cuda/blur_image/student_func.cu","focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-c","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/mnt/David/programming/cuda/blur_image/student_func.cu":1446172306028},"keybinding-resolver":{},"metrics":{"sessionLength":15874},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/home/david/programming/cuda/blur_image":{"isExpanded":true,"entries":{}}},"selectedPath":"/home/david/programming/cuda/blur_image","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":173}}}